{"name":"Buildbot-media","tagline":"Media around Buildbot - images, slides, papers, etc.","body":"\\documentclass[conference]{IEEEtran}\r\n\\usepackage{fancyvrb}\r\n\\usepackage{url}\r\n\\begin{document}\r\n\\title{Automating Build, Test, and Release with Buildbot}\r\n\r\n\r\n\\author{\\IEEEauthorblockN{Dustin J. Mitchell}\r\n\\IEEEauthorblockA{Mozilla, Inc.\\\\\r\nEmail: dustin@v.igoro.us}\r\n\\IEEEauthorblockN{Tom Prince}\r\n\\IEEEauthorblockA{Email: tom.prince@ualberta.net}\r\n}\r\n\r\n\\maketitle\r\n\r\n\\begin{abstract}\r\nBuildbot is a mature framework for building continuous integration systems which supports parallel execution of jobs across multiple platforms, flexible integration with version-control systems, extensive status reporting, and more.\r\nBeyond the capabilities it shares with similar tools, Buildbot has a number of unique strengths and capabilities, some of them particularly geared toward release processes.\r\nThis paper summarizes Buildbot's structure, contrasts the framework with related tools, describes some advanced configurations, and highlights ongoing improvements to the framework.\\footnote{This work is copyright (c) 2013 Dustin J. Mitchell and Tom Prince.  This work is licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/3.0/.}\r\n\\end{abstract}\r\n\r\n\\IEEEpeerreviewmaketitle\r\n\r\n\\section{Introduction}\r\n\r\nBuildbot is a continuous integration (CI) framework which has been in use for well over 10 years\\cite{buildbot-031}.\r\nWhile it began as a simple build-and-test tool, it has grown into an advanced  framework supporting continuous integration testing, continuous deployment, and release engineering.\r\nIts design allows an installation to grow with its requirements, beginning with a simple configuration and growing into a multi-master configuration with complex coordination of builds, each containing many sophisticated steps.\r\nThis flexibility has led to its use in a number of high-profile open-source projects, including Chromium, WebKit, Firefox, Python, and Twisted\\cite{success-stories}.\r\n\r\nBuildbot is but one of many tools commonly used for build, test, and release because, in such an active ecosystem, each tool has strengths that make it the best choice for certain purposes.\r\nBuildbot's niche is complex applications requiring extensive customization.\r\n\r\nThis paper briefly summarizes Buildbot's structure for background purposes then compares its framework to other tools.\r\nWe also describes some of the tool's unique features and capabilities and finishes with a description of ongoing work in the Buildbot development community.\r\n\r\n\\section{Buildbot's Structure}\r\n\r\nAt its core, Buildbot is a job scheduling system: it queues jobs (called \\emph{builds} for historical reasons), executes the jobs when the required resources are available, and reports the results.\r\nRefer to the Buildbot documentation\\cite{bb-introduction} for more detail.\r\n\r\nBuildbot's \\emph{change sources} watch for commits (generically called \\emph{changes}).\r\nThe built-in change sources support the most common version-control systems with flexible configuration to support a variety of deployments.\r\n\\emph{Schedulers} react to new data from change sources, external events, or triggers based on clock time (e.g., for a nightly build), and add new \\emph{build requests} to the queue.\r\n\r\nEach build request comes with a set of source stamps identifying the code from each codebase used for a build.\r\nA \\emph{source stamp} represents a particular revision and branch in a source code repository.\r\nBuild requests also specify a \\emph{builder} that should perform the task and a set of \\emph{properties}, arbitrary key-value pairs giving further detail about the requested build.\r\nEach \\emph{builder} defines the steps to take in executing a particular type of build.\r\nOnce the request is selected for execution, the steps are performed sequentially.\r\nEach build is executed on exactly one slave.\r\n\r\nBuildbot has a distributed master-slave architecture where the \\emph{masters} instruct the \\emph{slaves} to perform each step of a build in sequence.\r\nThe slave portion of Buildbot is platform-independent, and many slaves can be connected to each master, running builds in parallel.\r\nA slave may execute multiple builds simultaneously, as long as they are for different builders.\r\n\r\nOnce a build is complete, the framework reports the results---log files and step status---to users and developers via \\emph{status listeners}.\r\nBuildbot has built-in support for reporting via web, email, irc, Tinderbox, and gerrit.\r\n\r\nThe Buildbot master and slave are both implemented as Python daemons.\r\nSmall Buildbot installations are generally composed of one master and tens of slaves while larger installations run tens of masters with hundreds or thousands of slaves.\r\n\r\n\\section{Related Work}\r\n\r\nThe ecosystem of continuous integration testing tools is a busy one.\r\nThe Thoughtworks feature matrix\\cite{ci-feature-matrix} lists 28 packages and does not consider cloud-based services such as Travis-CI or TDDium.\r\n\r\n\\subsection{A Framework for Continuous Integration}\r\n\r\nMany CI packages, such as CruiseControl\\cite{cruisecontrol-getting-started} or Jenkins\\cite{meet-jenkins}, are structured as ready-to-use applications and embody assumptions about the structure of the project and its processes.\r\nUsers fill in specific details like version control information and build process, but the fundamental design is fixed and options are limited to those envisioned by the authors.\r\nThis arrangement suits the common cases quite well: there are cookie-cutter tools to automatically build and test Java applications, Ruby gems, and so on.\r\nThese tools are not well-suited to more complex cases, such as mixed-language applications or complex release tasks, where those assumptions are violated.\r\n\r\nIn contrast, Buildbot is designed as a framework: it provides tools for continuous integration and release management, allowing users to implement a system that suits their needs within that structure.\r\nWhile this makes Buildbot particularly well-suited to implementing the complex requirements of release engineering, it also means there is a steeper learning curve than with simpler CI applications.\r\n\r\n\\subsection{Configuration Interface}\r\n\r\nBuildbot does not support web-based configuration but instead requires the user to edit the sample configuration file before the first run.\r\nThis approach follows the UNIX philosophy of explicit, editable configuration---many Buildbot users keep their configuration in version control---and enables very fine control over the tool.\r\nIn contrast, the Jenkins web interface invites the user to add a project via the web interface---no configuration file is visible to the user.\r\nThe Buildbot community has discussed support for web-based configuration, e.g., \\cite{config-discussion}, but no robust implementation has emerged.\r\n\r\n\\subsection{Batteries Included}\r\n\r\nLike many CI applications, Jenkins ships with limited capabilities and uses a plug-in architecture\\cite{jenkins-plugins} to add additional capabilities.\r\nIn contrast, Buildbot includes many useful components in the base package and does not support plug-ins.\r\nThese components address common needs such as version control integration, specialized build tools, and flexible status reporting.\r\nIn many cases, the first implementation of Buildbot in an organization uses the built-in components, only replacing them with customized implementations as requirements grow.\r\nThis approach mirrors Python's notion of a \"Batteries Included\" language.\r\n\r\n\\subsection{Pull vs. Push}\r\n\r\nJob-queuing systems fall into two categories: push, where the central scheduler sends jobs to a worker it knows to be idle, and pull, where workers request jobs from the central scheduler.\r\nTools like Tinderbox\\cite{tinderbox} operate on a pull model whereby each tinderbox builds the latest revision in a tight loop, reporting status to the central tinderbox server.\r\nCruiseControl and Jenkins support both models.\r\nBuildbot operates exclusively on a push model: slaves simply perform the operations they receive from the master and then report the results.\r\nThe advantage of Buildbot's approach is that configuration is centralized on the masters.\r\nHowever, it is not well suited to cases where slave resources also serve other purposes since the Buildbot master lacks the context to determine if a slave is ready to perform a build.\r\n\r\n\\section{Advanced Buildbot Configuration}\r\n\r\nThis section highlights some of Buildbot's high-level capabilities and focuses on those that are useful in release management and operation at scale.\r\n\r\n\\subsection{Expressive Configuration}\r\n\r\nBuildbot's configuration file is simply a Python script.\r\nWhile a basic configuration can be written with little knowledge of Python, access to Python's power makes programmatic configuration trivial.\r\nFor example, a configuration with several identical Windows slaves might include this snippet to automatically generate each slave configuration:\r\n\r\n\\begin{Verbatim}\r\nfor n in range(0, 20):\r\n  c['slaves'].append(\r\n    BuildSlave('win-slave%d' % n, PASSWD))\r\n\\end{Verbatim}\r\n\r\nAll of the concepts introduced above--change sources, schedulers, slaves, builders, and status listeners--can be configured in this Python script.\r\nBasic configurations can use the built-in support while more advanced configurations include custom implementations.\r\n\r\nBuilder configurations include a list of steps to execute for each build (a \\emph{build factory}\\/).\r\nThese steps can be simple shell commands, built-in source checkout or build commands, or custom implementations.\r\nSteps can use and modify the build's properties, treating them as variables to coordinate the progress of the build.\r\n\r\nBuildbot supports dynamic reconfiguration without interrupting running builds, allowing adjustments to the build process without downtime.\r\n\r\n\\subsection{Multiple Codebases}\r\n\r\nBuildbot supports the increasingly common practice of building applications from multiple codebases.\r\nFor example, a mobile application might have three different codebases: \"Android\", \"iOS\", and \"Common\" which contains assets common to both implementations.\r\nBuildbot can monitor all three repositories and schedule android builds with source stamps from the \"Android\" and \"Common\" codebases when either one changes; likewise for \"iOS\".\r\nStatus is reported for the resulting multidimensional revision space.\r\n\r\n\\subsection{Scaling and Resiliency}\r\n\r\nLarge-scale Buildbot deployments run with both masters and slaves in a clustered configuration.\r\nThe masters use a shared relational database (MySQL or Postgres) to coordinate their actions.\r\nMultiple identically-configured slaves allow parallel execution of the same type of build for high-volume deployments and resiliency against slave failure.\r\n\r\nThe same slave can be configured on multiple masters in a cluster and then connect to any one of those masters.\r\nAssuming all masters are configured with the same builders, this allows resiliency against master failures.\r\nThe masters also share the load of processing status and logs, which can be substantial in a very busy cluster.\r\n\r\nAs an extreme example of Buildbot at scale, Mozilla's Buildbot deployment is comprised of over 40 masters and thousands of slaves.\r\nThis configuration handled a check-in every 6 minutes and performed 137 hours of build and test per check-in as of August 2012\\cite{mozilla-load}.\r\n\r\nOnly some of Buildbot's data is stored in the database with the remainder stored in on-disk \"pickle\" files as marshaled Python objects.\r\nHandling these pickles is inefficient, generating high IO load on the masters and considerably slowing processing.\r\nMore critically, the data on one master's disk is not accessible from another master, so analyzing builds distributed across a cluster is difficult.\r\nSection~\\ref{sec:ongoing-developments} describes ongoing work to address these shortcomings.\r\n\r\n\\subsection{Artifact Handling}\r\n\r\nFor a continuous-integration build, the important result is essentially boolean: did the build or tests fail?\r\nFor a release, the output is a set of binary artifacts---usually packages---ready for installation by end-users.\r\n\r\nBuildbot includes support for a few common package formats, although in most cases the package building process is driven by a project-specific script.\r\nBinary artifacts are generated on slaves as part of a build, and are then transmitted somewhere to make them accessible to users (or to the quality assurance team in a larger organization).\r\n\r\nArtifact upload steps are included with Buildbot, but the steps transfer the file data using a particularly inefficient mechanism (RPC, rather than a streaming protocol).\r\nFor any but the smallest installations, they are inadequate, performing poorly and causing performance issues for other builds on the same master.\r\nMost installations use SSH (via {\\tt scp}) or authenticated HTTP implemented in a shell command instead.\r\n\r\nThe Buildbot community has discussed integration with external tools\\cite{pull547}, but no compelling implementation has yet emerged.\r\n\r\n\\subsection{Build Coordination}\r\n\r\nIt is often desirable to perform multiple operations in parallel.\r\nThis can drastically reduce the end-to-end time (the time between a commit and completion of the last resulting job), and save a great deal of redundant computation.\r\n\r\nBecause Buildbot runs each build on a single slave, parallel operations must be represented as multiple builds.\r\nIn programming-language terms, builds form the \\emph{basic block} from which more complex control flows are constructed.\r\nThe remaining operations are to \"branch\" control into multiple builds, and then \"merge\" control back when those builds are complete.\r\n\r\nThe branching operation is accomplished by configuring a scheduler to queue build requests for multiple builders.\r\nThe resulting set of build requests comprise a \\emph{build set} and can be executed in parallel.\r\nIf slave resources are limited, the resulting builds may not actually execute concurrently, but they will be prioritized by Buildbot's multi-level priority configuration.\r\nThis technique provides a simple way to branch the control flow, but does not provide a way to perform some further action after all builds are complete.\r\n\r\nBuildbot provides two mechanisms for more sophisticated coordination: the \\emph{Dependent scheduler}, and the \\emph{Triggerable scheduler}.\r\nThe Dependent scheduler is configured to watch exactly one \"upstream\" scheduler.\r\nWhen all builds in a buildset initiated by this upstream scheduler complete successfully, the Dependent scheduler initiates its own set of builds.\r\nFor example, a Dependent scheduler might be used to schedule several test builds after all compilation builds are complete, allowing multiple test builds to share the same compiled artifacts.\r\n\r\nThe Triggerable scheduler initiates builds for its configured builders when triggered by a step in another build.\r\nThat step can either wait for the triggered builds to complete, or continue immediately.\r\nWaiting for the triggered builds provides a flexible method of merging control flow.\r\nIn a release build, for example, a Triggerable scheduler could be used to build localized versions of the application, one build per locale, triggered by a step in the compile build for each platform.\r\n\r\nThe most complex control flows are implemented as a single controlling build which triggers the necessary builds in sequence.\r\nFor example, such a build might trigger \"compile\" builds, followed by \"test\" builds if compile is successful, and followed by \"package\" builds, with each initiating builds on different slaves.\r\n\r\nBuildbot has ample room for improvement in support for build coordination.\r\nFirst, the framework provides no convenient means to summarize the output of a process that is spread over multiple builds.\r\nSecond, unusual branch and merge conditions, such as continuing when 80\\% of locales build successfully, are difficult to implement.\r\nFinally, a controlling build must be assigned to a slave, even though it never performs any operations on that slave.\r\n\r\nIn general, creating a concurrent build process is similar to assembly-language programming in that high-level constructs are not available.\r\nIdeally, Buildbot would make common structures like functions, loops, and conditionals available to users to structure these operations.\r\nThis is an as-yet unexplored area for future work.\r\n\r\n\\section{Ongoing Developments}\r\n\\label{sec:ongoing-developments}\r\n\r\n\\subsection{Nine: Fully Distributed, Scalable Architecture}\r\n\r\nBuildbot's developers, including the authors, are working to reformulate the tool as a collection loosely coupled modular components.\r\nThese components are linked by a common database back-end and a message bus.\r\nThey can be combined arbitrarily across multiple hosts to create build, test, and release systems customized to the needs of the user's organization.\r\n\r\nThis design allows redundant clustered implementations which are resilient to the failure of any single component and able to scale to meet load requirements.\r\nThe language-agnostic interfaces between components allow integration with other tools in an organization.\r\nFor example, Buildbot messages can be duplicated into an enterprise message bus and used to correlate build activity with other enterprise events.\r\n\r\nThe design also fixes a substantial performance problem in current versions of Buildbot.\r\nWeb status views are currently generated on the buildmaster using inefficient methods which can take up to 0.8s per page and which block all other activity on the master during generation.\r\nThis makes it unwise or impossible to expose the Buildbot web interface to a wide audience.\r\nThe web status views are rendered in the browser in the new design, significantly reducing load on masters.\r\nAs a further advantage, the master can send status updates directly to the web browser so that users see updated results without reloading the page.\r\n\r\nThe architecture is split into three layers: Database (DB), Message Queue (MQ), and Data.\r\nThe DB layer abstracts a shared relational database, supporting several common database packages.\r\nThe API presented by this layer is Python-only and is closely tied to the database schema.\r\n\r\nThe MQ layer implements a plug-able message queuing system.\r\nLike the DB layer, it supports several external backends, including RabbitMQ and ZeroMQ.\r\nThis layer distributes messages among all masters, providing notification of new events.\r\nAs an example, when a build is complete, the master processing that build sends a message.\r\nMessage consumers might react to that message by sending email, notifying users on IRC, or updating the display in a user's browser.\r\n\r\nThe Data layer combines access to stored state and messages, and exposes a well-defined API that can be used both within Buildbot and by external tools.\r\nBuildbot components use the data API to communicate with other components.\r\nThis layer's design is influenced by REST and is available both via HTTP and as a native Python interface.\r\n\r\nThis reformulation is nicknamed 'nine', because it is targeting Buildbot version 0.9.0.\r\nIt is a significant refactor of the Buildbot codebase, and work is slow due to the need to maintain compatibility.\r\nAs of this writing, most of the Data API is complete, and a proof-of-concept web interface has been written, but all status listeners remain unmodified.\r\nTime estimates are difficult for any open-source project, but it is likely that the project will be complete in late 2014.\r\n\r\n\\subsection{One-Oh: Well-Defined APIs}\r\n\r\nBuildbot is a fairly mature project and has grown considerably since it was created over a decade ago.\r\nMuch of that growth had been organic, driven by small contributions from users with little coordination of effort.\r\nThe documentation, while describing the configuration options, does not give much detail on how to customize Buildbot---hardly ideal for an application framework.\r\nLacking other guidance, users treat the source code as documentation.\r\nAs a result, the effective API surface of Buildbot has become large and ill-defined.\r\nThis has led to difficulty for users in upgrading Buildbot and made development of Buildbot itself difficult as quirks of the existing APIs hinder implementation of new features.\r\n\r\nThe fix is to define new APIs, make compatibility commitments about those APIs, and put tools in place to guarantee correctness and compatibility.\r\nThese APIs will include the Data API, as well as Python interfaces for custom change sources, schedulers, steps, and status-handling components.\r\nThe APIs will be fully documented and include thorough unit and interface tests measuring the implementation's behavior and adherence to the documentation.\r\nAny changes to the API will be handled carefully and communicated clearly to the Buildbot user community.\r\n\r\nIt is unrealistic to expect that the first Buildbot release implementing the Data API will get everything right.\r\nRather than commit to strict API compatibility beginning with Buildbot-0.9.0, the developers plan to allow the new APIs to \"settle in\" throughout the 0.9.x series.\r\nOnce Buildbot reaches version 1.0.0, the APIs will be fixed, and changes will be handled using accepted semantic-versioning techniques\\cite{semver}.\r\n\r\n\\section{Conclusion}\r\n\r\nBuildbot's flexibility can seem daunting for users with simple requirements, particularly in comparison to other tools.\r\nThat same flexibility makes it ideal for large, sophisticated build, test, and release implementations.\r\nThe tool is not without its weaknesses, several of which are indicated above.\r\nThe 'nine' project is an effort to address some of these weaknesses, and lay the groundwork for addressing others.\r\nThe 'one-oh' project will create a more hacker-friendly environment which should have a magnifying effect on the rate of development of new features and capabilities.\r\n\r\nAs an open source project, Buildbot welcomes all potential users and contributors.\r\nThe organization is pending membership in the Software Freedom Conservancy.\r\nIt has also participated in the Google Summer of Code for two years and hosts sprints (multi-day programming sessions) at PyCon every year.\r\nThe \\#buildbot IRC channel is an active and positive communication channel, as is the mailing list.\r\nThis environment has encouraged a broad developer community, with 71 contributors committing code in the last year alone and many more offering advice and support to other users.\r\n\r\n\\begin{thebibliography}{13}\r\n\r\n\\bibitem{ci-feature-matrix}\r\n\\textit{CI Feature Matrix} [online] 2013, \\url{http://confluence.public.thoughtworks.org/display/CC/CI+Feature+Matrix} (Accessed: 3 March 2013).\r\n\r\n\\bibitem{cruisecontrol-getting-started}\r\n\\textit{CruiseControl Getting Started} [online] 2013, \\url{http://cruisecontrol.sourceforge.net/gettingstarted.html} (Accessed: 3 March 2013).\r\n\r\n\\bibitem{config-discussion}\r\nGarboden, Mark.  \\textit{Buildbot config wizard} [online] 2006, \\url{http://comments.gmane.org/gmane.comp.python.buildbot.devel/554} (Accessed: 3 March 2013).\r\n\r\n\\bibitem{bb-introduction}\r\n\\textit{Introduction - Buildbot v0.8.7p1 documentation} [online] 2013, \\url{http://buildbot.net/buildbot/docs/current/manual/introduction.html} (Accessed: 3 March 2013).\r\n\r\n\\bibitem{meet-jenkins}\r\n\\textit{Meet Jenkins - Jenkins - Jenkins Wiki} [online] 2013, \\url{https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins} (Accessed: 3 March 2013).\r\n\r\n\\bibitem{mozilla-load}\r\nO'Duinn, John.  \\textit{137 hours compute hours every \\textasciitilde 6 minutes} [online] 2012, \\url{http://oduinn.com/blog/2012/08/21/137-hours-compute-hours-every-6-minutes/} (Accessed: 3 March 2013).\r\n\r\n\\bibitem{artifactory}\r\n\\textit{Open Source Overview} [online] 2013, \\url{http://www.jfrog.com/home/v_artifactory_opensource_overview} (Accessed: 3 March 2013).\r\n\r\n\\bibitem{jenkins-plugins}\r\n\\textit{Plugins - Jenkins - Jenkins Wiki} [online] 2013, \\url{https://wiki.jenkins-ci.org/display/JENKINS/Plugins} (Accessed: 3 March 2013).\r\n\r\n\\bibitem{semver}\r\nPrestoe-Werner, Tom. \\textit{Semantic Versioning 2.0.0-rc.1} [online] 2012, \\url{http://semver.org} (Accessed: 3 March 2013).\r\n\r\n\\bibitem{success-stories}\r\n\\textit{SuccessStories - Buildbot} [online] 2012, \\url{http://buildbot.net/trac/wiki/SuccessStories} (Accessed: 3 March 2013).\r\n\r\n\\bibitem{pull547}\r\nTardy, Pierre.  \\textit{ArtifactStorage management design doc} [online] 2012, \\url{https://github.com/buildbot/buildbot/pull/547} (Accessed: 3 March 2013).\r\n\r\n\\bibitem{tinderbox}\r\n\\textit{Tinderbox | MDN} [online] 2012, \\url{https://developer.mozilla.org/en-US/docs/Tinderbox} (Accessed: 3 March 2013)\r\n\r\n\\bibitem{buildbot-031}\r\nWarner, Brian.  \\textit{Buildbot 0.3.1} [online] 2003, \\url{https://raw.github.com/buildbot/buildbot/master/master/docs/relnotes/0.3.1.txt} (Accessed: 3 March 2013)\r\n\r\n\\end{thebibliography}\r\n\r\n\r\n\\end{document}\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}